// Generated by CoffeeScript 1.12.5
(function() {
  var $, BPM, MSPB, addGroup, audioContext, createStarfield, defs, director, groups, imageGroup, lastClicked, linkGroup, links, makeAudio, makeDetector, makeEmitter, makeNode, makePulser, nodeGroup, nodeProto, pulser, scopedTimers, starfield, svg, svgEl;

  $ = document.querySelector.bind(document);

  audioContext = new (window.AudioContext || window.webkitAudioContext);

  BPM = 127;

  MSPB = 1000 * 60 / BPM;

  makeEmitter = function(obj) {
    var listeners;
    if (obj == null) {
      obj = {};
    }
    listeners = {};
    obj.on = function(ev, f) {
      var ref;
      return (listeners[ev] = ((ref = listeners[ev]) != null ? ref.slice() : void 0) || []).push(f);
    };
    obj.un = function(ev, f) {
      return listeners[ev] = (listeners[ev] || []).filter(function(_f) {
        return _f !== f;
      });
    };
    obj.once = function(ev, f) {
      var unf;
      unf = function(data) {
        f(data);
        return obj.un(ev, unf);
      };
      return obj.on(ev, unf);
    };
    obj.emit = function(ev, data) {
      var f, j, len, ref, results;
      ref = listeners[ev] || [];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        f = ref[j];
        results.push(f(data));
      }
      return results;
    };
    obj.unlistenAll = function() {
      return listeners = {};
    };
    return obj;
  };

  scopedTimers = function() {
    var intervals, timeouts;
    timeouts = [];
    intervals = [];
    return {
      setTimeout: function(f, t) {
        return timeouts.push(setTimeout(f, t));
      },
      setInterval: function(f, t) {
        return intervals.push(setInterval(f, t));
      },
      clear: function() {
        var j, len, len1, n, t;
        for (j = 0, len = timeouts.length; j < len; j++) {
          t = timeouts[j];
          clearTimeout(t);
        }
        for (n = 0, len1 = intervals.length; n < len1; n++) {
          t = intervals[n];
          clearInterval(t);
        }
        timeouts = [];
        return intervals = [];
      }
    };
  };

  makeAudio = function(src) {
    var audioNode, buffer, getBuffer, load, nearTime, play, playAfter, stop, timers;
    buffer = null;
    audioNode = null;
    nearTime = 500;
    timers = scopedTimers();
    getBuffer = function() {
      if (buffer) {
        return Promise.resolve(buffer);
      }
      return fetch(src).then(function(response) {
        return response.arrayBuffer();
      }).then(function(audioData) {
        return new Promise(function(accept) {
          return audioContext.decodeAudioData(audioData, accept);
        });
      }).then(function(_buffer) {
        buffer = _buffer;
        return buffer;
      });
    };
    load = function() {
      return getBuffer();
    };
    play = function(at) {
      return getBuffer().then((function(_this) {
        return function(buffer) {
          var timeout;
          if (audioNode) {
            return;
          }
          if (at == null) {
            at = audioContext.currentTime;
          }
          audioNode = audioContext.createBufferSource();
          audioNode.buffer = buffer;
          audioNode.connect(pulser.node);
          audioNode.connect(audioContext.destination);
          audioNode.start(at);
          _this.start = at;
          _this.duration = buffer.duration;
          audioNode.onended = function() {
            console.log('ended');
            return _this.emit('ended');
          };
          timers.setTimeout(function() {
            return _this.emit('started');
          }, (at - audioContext.currentTime) * 1000);
          timeout = Math.max(0, Math.round((at - audioContext.currentTime + buffer.duration) * 1000 - nearTime));
          return timers.setTimeout(function() {
            console.log("near", Date.now() % 100000);
            return _this.emit('near');
          }, Math.max(0, (at - audioContext.currentTime + buffer.duration) * 1000 - nearTime));
        };
      })(this));
    };
    playAfter = function(otherNode) {
      return this.play(otherNode.start + otherNode.duration);
    };
    stop = function() {
      timers.clear();
      this.unlistenAll();
      this.start = null;
      this.duration = null;
      if (audioNode != null) {
        audioNode.disconnect();
      }
      if (this.start) {
        audioNode.stop();
      }
      return audioNode = null;
    };
    return makeEmitter({
      load: load,
      play: play,
      playAfter: playAfter,
      stop: stop
    });
  };

  makeDetector = function(opts) {
    var analyser, buffer, detect, filter, idx, max, min, ringbufSize, samples;
    if (opts == null) {
      opts = {};
    }
    filter = audioContext.createBiquadFilter();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = opts.fftSize || 512;
    filter.connect(analyser);
    buffer = new Uint8Array(analyser.fftSize);
    min = null;
    max = null;
    ringbufSize = opts.ringbufSize || 360;
    samples = new Float32Array(ringbufSize);
    idx = 0;
    detect = function() {
      var avg, j, len, len1, n, sample, val;
      analyser.getByteTimeDomainData(buffer);
      avg = 0;
      for (j = 0, len = buffer.length; j < len; j++) {
        val = buffer[j];
        avg += Math.abs(val - 128);
      }
      avg /= buffer.length;
      min = null;
      max = null;
      for (n = 0, len1 = samples.length; n < len1; n++) {
        sample = samples[n];
        if ((min == null) || sample < min) {
          min = sample;
        }
        if ((max == null) || sample > max) {
          max = sample;
        }
      }
      samples[idx] = avg;
      idx = (idx + 1) % ringbufSize;
      return Math.round(Math.min((avg - min) / (max - min), 1) * 1000) / 1000;
    };
    return {
      filter: filter,
      analyser: analyser,
      buffer: buffer,
      detect: detect,
      "in": filter,
      out: analyser
    };
  };

  makePulser = function(opts) {
    var attach, attachedEl, beatDetector, detach, diffi, diffs, draw, drawing, lastbeat, lastscale, lastt, maxdiff, melodyDetector, mindiff, node, numdiffs, rot, rotdecay, rotdir, rotvelocity, stopped;
    if (opts == null) {
      opts = {};
    }
    node = audioContext.createGain();
    beatDetector = makeDetector();
    beatDetector.filter.frequency.value = 100;
    beatDetector.filter.Q.value = 1;
    beatDetector.filter.type = 'lowpass';
    node.connect(beatDetector["in"]);
    melodyDetector = makeDetector({
      ringbufSize: 120,
      fftSize: 256
    });
    melodyDetector.filter.frequency.value = 1200;
    window.freq = melodyDetector.filter.frequency;
    melodyDetector.filter.Q.value = 1.66;
    window.Q = melodyDetector.filter.Q;
    melodyDetector.filter.type = 'bandpass';
    node.connect(melodyDetector["in"]);
    drawing = false;
    stopped = false;
    attachedEl = null;
    rot = 0;
    rotdir = 1;
    rotdecay = 0.90;
    lastt = null;
    lastbeat = null;
    numdiffs = 8;
    diffs = new Array(numdiffs);
    diffi = 0;
    mindiff = MSPB / 4;
    maxdiff = MSPB * 4;
    rotvelocity = maxdiff;
    lastscale = 1;
    draw = function() {
      return requestAnimationFrame(function(t) {
        var avgdiff, beat, beatdiff, diff, diffcount, j, len, melody, newscale, oldrot, scale, thisdiff, totaldiff;
        if (stopped) {
          drawing = false;
          return;
        }
        beat = beatDetector.detect();
        melody = melodyDetector.detect();
        if (lastt) {
          diff = t - lastt;
          if (melody > 0.5) {
            beatdiff = t - lastbeat;
            if (lastbeat && (maxdiff >= beatdiff && beatdiff >= mindiff)) {
              diffs[diffi] = beatdiff;
              diffi = (diffi + 1) % numdiffs;
              totaldiff = 0;
              diffcount = 0;
              for (j = 0, len = diffs.length; j < len; j++) {
                thisdiff = diffs[j];
                if (!(thisdiff != null)) {
                  continue;
                }
                totaldiff += thisdiff;
                diffcount += 1;
              }
              avgdiff = totaldiff / diffcount;
              rotvelocity = avgdiff;
            }
            lastbeat = t;
          }
          if (rotvelocity > 0) {
            rot += (diff / rotvelocity * 30) % 60 * rotdir;
          }
          oldrot = rot;
          if (rot > 30) {
            rot = 30 - (rot - 30);
            rotdir = -1;
          }
          if (rot < -30) {
            rot = -30 - (rot + 30);
            rotdir = 1;
          }
        }
        scale = 1 + beat;
        newscale = !lastscale || scale > lastscale ? scale : (scale + lastscale) / 2;
        attachedEl.style.transform = "scale(" + newscale + ") rotate(" + rot + "deg)";
        lastscale = newscale;
        lastt = t;
        return draw();
      });
    };
    attach = function(node) {
      stopped = false;
      attachedEl = node.el;
      if (!drawing) {
        draw();
      }
      return drawing = true;
    };
    detach = function() {
      stopped = true;
      return attachedEl = null;
    };
    return {
      node: node,
      attach: attach,
      detach: detach
    };
  };

  pulser = makePulser();

  svg = document.querySelector('svg');

  svgEl = function(name, attribs) {
    var el, k, v;
    if (attribs == null) {
      attribs = {};
    }
    el = document.createElementNS('http://www.w3.org/2000/svg', name);
    for (k in attribs) {
      v = attribs[k];
      el.setAttribute(k, v);
    }
    return el;
  };

  defs = svgEl('defs');

  svg.appendChild(defs);

  linkGroup = svgEl('g', {
    'opacity': 1
  });

  nodeGroup = svgEl('g');

  imageGroup = svgEl('g');

  svg.appendChild(imageGroup);

  svg.appendChild(linkGroup);

  svg.appendChild(nodeGroup);

  groups = {};

  addGroup = function(name, group) {
    groups[name] = group;
    group.name = name;
    if (group.image) {
      group.imageEl = svgEl('image', {
        href: "images/" + group.image.name + ".png",
        x: group.image.x,
        y: group.image.y,
        width: group.image.w,
        height: group.image.h,
        style: "transition: opacity 50ms ease-in-out",
        opacity: (group.image.hidden ? 0 : 1)
      });
      group.imageEl.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', "images/" + group.image.name + ".png");
      imageGroup.appendChild(group.imageEl);
    }
    group.activate = function() {
      if (group.image.hidden) {
        return group.imageEl.setAttribute('opacity', 1);
      }
    };
    return group.deactivate = function() {};
  };

  links = (function() {
    var add, all, allLinks, get, make, makeGradient, reset;
    allLinks = {};
    makeGradient = function(from, to) {
      var id, linkGrad, linkStartGrad, linkStopGrad, ref, ref1;
      id = "grad-" + from.name + "--" + to.name;
      linkGrad = svgEl('linearGradient', {
        id: id,
        gradientUnits: 'userSpaceOnUse',
        x1: from.x,
        y1: from.y,
        x2: to.x,
        y2: to.y
      });
      linkStartGrad = svgEl('stop', {
        offset: '0%',
        'stop-opacity': 1,
        'stop-color': ((ref = from.group) != null ? ref.stroke : void 0) || '#ffffff'
      });
      linkStopGrad = svgEl('stop', {
        offset: '100%',
        'stop-opacity': 1,
        'stop-color': ((ref1 = to.group) != null ? ref1.stroke : void 0) || '#ffffff'
      });
      linkGrad.appendChild(linkStartGrad);
      linkGrad.appendChild(linkStopGrad);
      defs.appendChild(linkGrad);
      return id;
    };
    make = function(from, to) {
      var activate, crossGroup, d, deactivate, dx, dy, el, gradient, line, m, prepare, x1, x2, y1, y2;
      el = svgEl('g', {
        stroke: '#fff',
        'stroke-width': 4
      });
      el.style.transition = 'all 0.5s ease-in-out';
      linkGroup.appendChild(el);
      dx = to.x - from.x;
      dy = to.y - from.y;
      m = dy / dx;
      d = Math.sqrt(dy * dy + dx * dx);
      x1 = from.x + dx * (10 / d);
      y1 = from.y + dy * (10 / d);
      x2 = to.x - dx * (10 / d);
      y2 = to.y - dy * (10 / d);
      line = svgEl('line', {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      });
      el.appendChild(line);
      if (from.group !== to.group) {
        crossGroup = true;
        el.setAttribute('stroke-dasharray', '25,20');
        el.setAttribute('opacity', 0);
        gradient = makeGradient(from, to);
      }
      prepare = function() {
        if (crossGroup) {
          return el.setAttribute('opacity', 1);
        }
      };
      activate = function() {
        if (crossGroup) {
          el.setAttribute('opacity', 1);
          el.setAttribute('stroke', "url(#" + gradient + ")");
        } else {
          el.setAttribute('stroke', from.group.stroke || '#ffffff');
        }
        return linkGroup.appendChild(el);
      };
      deactivate = function() {
        el.setAttribute('stroke', 'white');
        if (crossGroup) {
          return el.setAttribute('opacity', 0);
        }
      };
      return {
        prepare: prepare,
        activate: activate,
        deactivate: deactivate
      };
    };
    add = function(from, to) {
      return allLinks[from.name + ":" + to.name] = make(from, to);
    };
    get = function(from, to) {
      return allLinks[from.name + ":" + to.name];
    };
    all = function(f) {
      var _, link, results;
      results = [];
      for (_ in allLinks) {
        link = allLinks[_];
        results.push(f(link));
      }
      return results;
    };
    reset = function() {
      var _, link, results;
      results = [];
      for (_ in allLinks) {
        link = allLinks[_];
        results.push(link.deactivate());
      }
      return results;
    };
    return {
      add: add,
      get: get,
      all: all,
      reset: reset
    };
  })();

  lastClicked = null;

  nodeProto = {
    render: function() {
      var circle, el, r, r2, shapeCoords, spokes, stellated, svgpoints, x, y;
      if (this.el) {
        return;
      }
      this.el = el = svgEl('g', {
        opacity: 1,
        style: "transform-origin: " + this.x + "px " + this.y + "px; transform:scale(0.5); cursor: pointer"
      });
      this.el.addEventListener('click', (function(_this) {
        return function() {
          if (lastClicked === _this) {
            director.jump(_this);
          } else {
            director.navigate(_this);
          }
          return lastClicked = _this;
        };
      })(this));
      x = this.x;
      y = this.y;
      r = 40;
      r2 = 20;
      shapeCoords = function(cx, cy, r, steps, offset) {
        var i, j, ref, results;
        if (offset == null) {
          offset = 0;
        }
        results = [];
        for (i = j = 0, ref = steps; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push({
            x: cx + Math.sin(2 * Math.PI / steps * i + offset) * r,
            y: cy + Math.cos(2 * Math.PI / steps * i + offset) * r
          });
        }
        return results;
      };
      stellated = function(cx, cy, r1, r2, steps) {
        var coords1, coords2, i, j, ref, ret;
        coords1 = shapeCoords(cx, cy, r1, steps);
        coords2 = shapeCoords(cx, cy, r2, steps, Math.PI / steps);
        ret = [];
        for (i = j = 0, ref = coords1.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          ret.push(coords1[i], coords2[i]);
        }
        return ret;
      };
      svgpoints = function(points) {
        var p;
        return ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = points.length; j < len; j++) {
            p = points[j];
            results.push(p.x + "," + p.y);
          }
          return results;
        })()).join(' ');
      };
      this.circle = circle = svgEl('circle', {
        cx: x,
        cy: y,
        r: r2,
        fill: this.group.fill,
        stroke: 'black'
      });
      this.spokes = spokes = svgEl('polygon', {
        points: svgpoints(stellated(x, y, r2, r, 9)),
        fill: this.group.fill,
        stroke: 'black',
        opacity: 0
      });
      el.appendChild(spokes);
      el.appendChild(circle);
      return nodeGroup.appendChild(el);
    },
    activate: function() {
      nodeGroup.appendChild(this.el);
      if (lastClicked === this) {
        lastClicked = null;
      }
      this.el.setAttribute('opacity', 1.0);
      this.el.style.transform = 'scale(1.0)';
      this.circle.setAttribute('fill', this.group.stroke);
      if (!this.group.nospokes) {
        return this.spokes.setAttribute('opacity', 1.0);
      }
    },
    deactivate: function() {
      this.circle.setAttribute('fill', this.group.fill);
      this.el.setAttribute('opacity', 1.0);
      this.el.style.transform = 'scale(0.5)';
      return this.spokes.setAttribute('opacity', 0);
    },
    link: function(nodes, weight) {
      var j, len, next, node;
      if (weight == null) {
        weight = 1;
      }
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        links.add(this, node);
        next = {
          node: node,
          weight: weight
        };
        this.nexts.push(next);
      }
      return this;
    }
  };

  makeNode = function(src, data) {
    var j, k, len, o, ref;
    o = Object.create(nodeProto);
    o.src = src;
    o.nexts = [];
    o.name = src.split('/').pop().split('.')[0];
    o.audio = makeAudio(src);
    ref = 'x y label rate rates mode'.split(' ');
    for (j = 0, len = ref.length; j < len; j++) {
      k = ref[j];
      o[k] = data[k];
    }
    o.group = groups[data.group];
    o.render();
    return o;
  };

  director = (function() {
    var activateNext, currentNode, deactivateCurrent, finish, getNext, jump, navigate, nodeList, nodeTimers, pathTo, prepareNext, scheduleNext, scheduledNode, unScheduleNode, updateStarfield;
    nodeList = [];
    currentNode = null;
    scheduledNode = null;
    nodeTimers = scopedTimers();
    prepareNext = function() {
      var j, len, next, ref;
      if (!nodeList.length) {
        next = getNext();
        if (!next) {
          return finish();
        }
        nodeList.push(next);
        ref = currentNode.nexts;
        for (j = 0, len = ref.length; j < len; j++) {
          next = ref[j];
          links.get(currentNode, next.node).prepare();
        }
        nodeTimers.setTimeout(function() {
          return links.get(currentNode, nodeList[0]).activate();
        }, 1000);
      }
      return nodeList[0].audio.load();
    };
    getNext = function() {
      var cur, j, len, next, rand, ref, total;
      total = currentNode.nexts.reduce((function(total, next) {
        return total + next.weight;
      }), 0);
      rand = Math.random() * total;
      cur = 0;
      ref = currentNode.nexts;
      for (j = 0, len = ref.length; j < len; j++) {
        next = ref[j];
        cur += next.weight;
        if (rand <= cur) {
          return next.node;
        }
      }
    };
    deactivateCurrent = function() {
      var j, len, next, ref;
      nodeTimers.clear();
      currentNode.deactivate();
      currentNode.group.deactivate();
      currentNode.audio.stop();
      ref = currentNode.nexts;
      for (j = 0, len = ref.length; j < len; j++) {
        next = ref[j];
        links.get(currentNode, next.node).deactivate();
      }
      pulser.detach();
      return currentNode = null;
    };
    activateNext = function() {
      if (currentNode) {
        deactivateCurrent();
      }
      currentNode = nodeList.shift();
      scheduledNode = null;
      currentNode.activate();
      currentNode.group.activate();
      pulser.attach(currentNode);
      updateStarfield();
      return prepareNext();
    };
    scheduleNext = function() {
      var nextNode;
      if (!(nextNode = nodeList[0])) {
        return prepareNext();
      }
      if (scheduledNode) {
        unScheduleNode();
      }
      if (currentNode) {
        nextNode.audio.playAfter(currentNode.audio);
      } else {
        nextNode.audio.play();
      }
      nextNode.audio.once('near', scheduleNext);
      nextNode.audio.once('started', activateNext);
      return scheduledNode = nextNode;
    };
    unScheduleNode = function() {
      scheduledNode.audio.stop();
      return scheduledNode = null;
    };
    updateStarfield = function() {
      var i, j, len, rate, ref, results;
      starfield.setMode(currentNode.mode || currentNode.group.mode || 'static');
      if (currentNode.rates) {
        starfield.setRate(currentNode.rates[0]);
        ref = currentNode.rates;
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          rate = ref[i];
          if (i !== 0) {
            results.push((function(_this) {
              return function(rate, i) {
                return nodeTimers.setTimeout(function() {
                  return starfield.setRate(rate);
                }, currentNode.audio.duration / currentNode.rates.length * i * 1000);
              };
            })(this)(rate, i));
          }
        }
        return results;
      } else {
        return starfield.setRate(currentNode.rate || currentNode.group.rate || 1);
      }
    };
    pathTo = function(node) {
      var j, len, next, path, ref, thisNode, visited, visiting;
      visited = {};
      visiting = [
        {
          node: currentNode
        }
      ];
      while (thisNode = visiting.shift()) {
        if (thisNode.node === node) {
          path = [];
          while (thisNode.from) {
            path.push(thisNode.node);
            thisNode = thisNode.from;
          }
          return path.reverse();
        }
        ref = thisNode.node.nexts;
        for (j = 0, len = ref.length; j < len; j++) {
          next = ref[j];
          if (!(!visited[next.node.name])) {
            continue;
          }
          visiting.push({
            node: next.node,
            from: thisNode
          });
          visited[next.node.name] = true;
        }
      }
    };
    navigate = function(node) {
      var j, len, newNodeList, prevNode, results;
      if (!currentNode) {
        return jump(node);
      }
      if (!(newNodeList = pathTo(node))) {
        return;
      }
      nodeList = newNodeList;
      scheduleNext();
      prevNode = currentNode;
      links.reset();
      results = [];
      for (j = 0, len = nodeList.length; j < len; j++) {
        node = nodeList[j];
        links.get(prevNode, node).activate();
        results.push(prevNode = node);
      }
      return results;
    };
    jump = function(node) {
      links.reset();
      starfield.resync();
      if (currentNode) {
        deactivateCurrent();
      }
      nodeList = [node];
      return scheduleNext();
    };
    finish = function() {
      return currentNode.audio.on('ended', function() {
        if (currentNode) {
          return deactivateCurrent();
        }
      });
    };
    return {
      navigate: navigate,
      prepareNext: prepareNext,
      getNext: getNext,
      navigate: navigate,
      jump: jump
    };
  })();

  window.director = director;

  createStarfield = function() {
    var canvas, ctx, currentFadeRate, currentMode, draw, j, len, mode, modes, needsResync, p, pixels, rate, resync, scale, setMode, setRate, startt, step, targetFadeRate;
    canvas = $('#starfield');
    scale = 2;
    canvas.width = canvas.offsetWidth / scale;
    canvas.height = canvas.offsetHeight / scale;
    window.addEventListener('resize', function() {
      var j, len, oldHeight, oldWidth, p, results;
      oldWidth = canvas.width;
      oldHeight = canvas.height;
      canvas.width = canvas.offsetWidth / scale;
      canvas.height = canvas.offsetHeight / scale;
      ctx.width = canvas.width;
      ctx.height = canvas.height;
      results = [];
      for (j = 0, len = pixels.length; j < len; j++) {
        p = pixels[j];
        p.x = Math.round(p.x * canvas.width / oldWidth);
        results.push(p.y = Math.round(p.y * canvas.height / oldHeight));
      }
      return results;
    });
    ctx = canvas.getContext('2d');
    ctx.width = canvas.width;
    ctx.height = canvas.height;
    ctx.fillStyle = 'white';
    pixels = (function() {
      var j, results;
      results = [];
      for (j = 1; j <= 500; j++) {
        results.push({
          x: Math.floor(Math.random() * ctx.width),
          y: Math.floor(Math.random() * ctx.height),
          w: 1,
          h: 1,
          r: 255,
          g: 255,
          b: 255,
          a: Math.random()
        });
      }
      return results;
    })();
    for (j = 0, len = pixels.length; j < len; j++) {
      p = pixels[j];
      p.phase = p.a;
    }
    mode = 'static';
    rate = 1;
    step = function(p, beats) {
      return currentMode.step(p, beats);
    };
    modes = {
      "static": {
        noRedraw: true,
        step: function() {}
      },
      twinkle: {
        step: function(p, beats) {
          var level;
          level = ((beats + p.phase) * rate) % 2;
          if (level > 1) {
            return p.a = 2 - level;
          } else {
            return p.a = level;
          }
        },
        teardown: function(p) {
          return p.a = p.phase;
        },
        transitions: {
          fly: function() {
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            return ctx.fillRect(0, 0, ctx.width, ctx.height);
          }
        }
      },
      fly: {
        setup: function(p) {
          p.h = 5 * scale * rate * p.phase;
          return p.a = p.phase / 2;
        },
        step: function(p, beats) {
          return p.y = (p.y + 5 * scale * rate * p.phase) % ctx.height;
        },
        fadeRate: 0.1,
        teardown: function(p) {
          p.a = p.phase;
          return p.h = 1;
        }
      },
      yaw: {
        setup: function(p) {
          return p.h = 4 * scale * rate * p.phase;
        },
        step: function(p, beats) {
          var yaw;
          yaw = (beats / 8 * scale * rate) % 2;
          if (yaw > 1) {
            yaw = 1 - yaw;
          }
          p.x = (p.x + Math.max(Math.min(yaw * 4, 0.25), -0.25) * scale * p.phase) % ctx.width;
          if (p.x < 0) {
            p.x += ctx.width;
          }
          return p.y = (p.y + 4 * rate * scale * p.phase) % ctx.height;
        },
        fadeRate: 0.1,
        teardown: function(p) {
          p.h = 1;
          return p.w = 1;
        }
      },
      surf: {
        setup: function(p) {
          p.w = 2 * p.phase;
          return p.h = 2 * p.phase;
        },
        step: function(p, beats) {
          var val, yaw;
          val = (beats / 2 * rate) % 2;
          yaw = Math.sin(val * Math.PI);
          p.x = (p.x + yaw * scale * p.phase) % ctx.width;
          if (p.x < 0) {
            p.x += ctx.width;
          }
          return p.y = (p.y + scale * p.phase * rate) % ctx.height;
        },
        fadeRate: 1,
        teardown: function(p) {
          p.w = 1;
          return p.h = 1;
        }
      },
      fall: {
        step: function(p, beats) {
          p.h = rate * scale * p.phase;
          p.y = p.y - rate * scale * p.phase;
          if (p.y < 0) {
            return p.y += ctx.height;
          }
        },
        fadeRate: 0.25,
        teardown: function(p) {
          return p.h = 1;
        },
        transitions: {
          fly: function() {
            var len1, n, results;
            results = [];
            for (n = 0, len1 = pixels.length; n < len1; n++) {
              p = pixels[n];
              results.push(ctx.fillRect(p.x, 0, p.w, ctx.height));
            }
            return results;
          }
        }
      },
      circles: {
        setup: function(p) {
          p.w = scale / 2 * p.phase;
          p.h = scale / 2 * p.phase;
          return p.dir = Math.random() > 0.5 ? -1 : 1;
        },
        step: function(p, beats) {
          var r, val;
          val = (beats / 2 * rate * p.phase + p.phase * 2) % 2;
          r = Math.min(rate, 2) * scale / 4;
          p.x += Math.sin(val * Math.PI) * r * p.dir;
          p.y += Math.cos(val * Math.PI) * r * p.dir;
          if (Math.random() > 1 - rate * 0.02) {
            return p.dir *= -1;
          }
        },
        fadeRate: 0.05,
        teardown: function(p) {
          p.w = 1;
          return p.h = 1;
        }
      },
      contact: {
        setup: function() {
          p.r = Math.floor(Math.random() * 255);
          p.g = Math.floor(Math.random() * 255);
          p.b = Math.floor(Math.random() * 255);
          p.ox = p.x;
          return p.oy = p.y;
        },
        step: function(p, beats) {
          var level;
          level = ((beats / 4 + p.phase) * rate / 2) % 2;
          if (level > 1) {
            p.a = 2 - level;
          } else {
            p.a = level;
          }
          p.w = 2 * p.a * rate;
          p.h = 2 * p.a * rate;
          p.x = p.ox - p.w / 2;
          p.y = p.oy - p.h / 2;
          p.oy = p.oy - rate * Math.min(1, p.phase * 2) / 4;
          if (p.oy < 0) {
            return p.oy += ctx.height;
          }
        },
        fadeRate: 1,
        teardown: function(p) {
          p.a = p.phase;
          p.r = p.g = p.b = 255;
          p.w = 1;
          return p.h = 1;
        }
      },
      swirls: {
        setup: function(p) {
          p.dir = 1;
          p.rad = 1;
          p.ox = p.x;
          p.oy = p.y;
          return p.oc = {
            r: Math.floor(Math.random() * 255),
            g: Math.floor(Math.random() * 255),
            b: Math.floor(Math.random() * 255)
          };
        },
        step: function(p, beats) {
          var b, cx, cy, g, r, val;
          val = (beats / 4 + p.phase * 2) % 1;
          cx = ctx.width / 2;
          cy = ctx.height / 2;
          p.w = 8 * p.a * (1 - val);
          p.h = 8 * p.a * (1 - val);
          r = Math.round((Math.min(1, 4 / rate) + p.phase) / 2 * 255);
          g = Math.round((Math.min(1, rate / 4) + (1 - p.phase)) / 2 * 255);
          b = Math.round(p.phase * 127);
          p.r = Math.round(r * val * 4 + p.oc.r * (1 - val) / 4);
          p.g = Math.round(g * val * 4 + p.oc.g * (1 - val) / 4);
          p.b = Math.round(b * val * 4 + p.oc.b * (1 - val) / 4);
          p.x = p.ox * (1 - val) + cx * val;
          return p.y = p.oy * (1 - val) + cy * val;
        },
        fadeRate: 0.1,
        teardown: function(p) {
          p.x = p.ox;
          p.y = p.oy;
          p.h = p.w = 1;
          return p.r = p.g = p.b = 255;
        }
      }
    };
    currentMode = modes["static"];
    startt = null;
    needsResync = true;
    currentFadeRate = 1;
    targetFadeRate = 1;
    draw = function() {
      return requestAnimationFrame(function(t) {
        var diff, last, len1, n;
        if (needsResync) {
          startt = t;
          needsResync = false;
        }
        diff = t - startt;
        if (currentFadeRate !== targetFadeRate) {
          if (targetFadeRate < currentFadeRate) {
            currentFadeRate = targetFadeRate;
          } else {
            currentFadeRate = (currentFadeRate * 19 + targetFadeRate) / 20;
          }
        }
        ctx.fillStyle = "rgba(0, 0, 0, " + currentFadeRate + ")";
        ctx.fillRect(0, 0, ctx.width, ctx.height);
        last = {};
        for (n = 0, len1 = pixels.length; n < len1; n++) {
          p = pixels[n];
          if (p.r !== last.r || p.g !== last.g || p.b !== last.b || p.a !== last.a) {
            ctx.fillStyle = "rgba(" + p.r + "," + p.g + "," + p.b + "," + p.a + ")";
          }
          ctx.fillRect(p.x, p.y, p.w, p.h);
          if (diff > 0) {
            step(p, diff / MSPB);
          }
          last = p;
        }
        if (!(currentMode.noRedraw && diff > 60)) {
          return draw();
        }
      });
    };
    draw();
    setMode = function(mode) {
      var len1, n, newMode, ref, ref1;
      newMode = modes[mode];
      if (currentMode.noRedraw) {
        draw();
      }
      if ((ref = currentMode.transitions) != null) {
        if (typeof ref[mode] === "function") {
          ref[mode]();
        }
      }
      if (currentMode !== newMode) {
        needsResync = true;
        for (n = 0, len1 = pixels.length; n < len1; n++) {
          p = pixels[n];
          if (currentMode.teardown) {
            currentMode.teardown(p);
          }
          if (newMode.setup) {
            newMode.setup(p);
          }
          p.x = Math.round(p.x);
          p.y = Math.round(p.y);
        }
      }
      targetFadeRate = (ref1 = newMode.fadeRate) != null ? ref1 : 1;
      return currentMode = newMode;
    };
    setRate = function(_rate) {
      if (rate !== _rate) {
        needsResync = true;
      }
      return rate = _rate;
    };
    resync = function() {
      return needsResync = true;
    };
    window.setMode = setMode;
    window.setRate = setRate;
    return {
      setMode: setMode,
      setRate: setRate,
      resync: resync
    };
  };

  starfield = createStarfield();

  (function() {
    var canOgg, ext, nodes;
    canOgg = document.createElement('audio').canPlayType('audio/ogg');
    ext = canOgg ? 'ogg' : 'mp3';
    nodes = {};
    return fetch('data.json').then(function(result) {
      return result.json();
    }).then(function(data) {
      var _links, group, groupName, k, l, ref, ref1, ref2, ref3, v, weight;
      ref = data.groups;
      for (groupName in ref) {
        group = ref[groupName];
        addGroup(groupName, group);
      }
      ref1 = data.nodes;
      for (k in ref1) {
        v = ref1[k];
        nodes[k] = makeNode("media/" + k + "." + ext, v);
      }
      ref2 = data.nodes;
      for (k in ref2) {
        v = ref2[k];
        ref3 = v.links;
        for (weight in ref3) {
          _links = ref3[weight];
          nodes[k].link((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = _links.length; j < len; j++) {
              l = _links[j];
              results.push(nodes[l]);
            }
            return results;
          })(), Number(weight));
        }
      }
      return nodes.countdown_6.audio.load();
    }).then(function() {
      $('#click').style.opacity = 1;
      return $('#splash').addEventListener('click', function() {
        var ref;
        audioContext.resume();
        if ((ref = navigator.audioSession) != null) {
          ref.type = 'playback';
        }
        director.jump(nodes.countdown_6);
        return $('#splash').remove();
      });
    });
  })();

}).call(this);
